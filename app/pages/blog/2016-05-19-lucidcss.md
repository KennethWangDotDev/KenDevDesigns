---
title: LucidCSS
layout: blog-post
root: blog
nav-blog: true
date: 2016-05-19
collection:
  - blog
  - webdev

thumbnail: blog/lucidcss/thumbnail.png

description: "I want to share with everyone my CSS style guide that I have been experimenting with and found great success with. I call it LucidCSS."
---

Over the past years, I've tried many CSS style guides. I've tried OOCSS; I've tried SMACSS; I've tried naming conventions like BEM; I've tried company-wide style guides like Trello's Style Guide. All of them were *okay*, but I felt that they were missing something.


I want to share with everyone my CSS style guide that I have been experimenting with and found great success with. I call it LucidCSS.

> luÂ·cid<br/>
> very clear and easy to understand
><cite>Merriam-Webster</cite>

I believe that there are three goals to any CSS style guide:

1. Maintainable and scalable.
2. Allows for rapid development.
3. Overcomes specificity problems.

*LucidCSS* adds a fourth goal:

4. Extremely simple.

CSS is complicated as heck, and I believe that we should strive to make our CSS writing as simple as possible.

Before I get started, I should mention that LucidCSS does require a CSS pre-processor. I use Sass, and so will this guide. Now without further ado, let's do this!

## Complete Separation of Concerns

Style and architecture should be *completely* separated. Here's a snippet of some HTML using Bootstrap that I found online:

```html
<div class="col-xs-3 col-md-1 col-lg-1 social-btn-container">
    <a href="#" class="btn btn-social btn-block btn-google">Google</a>
    <a href="#" class="btn btn-social btn-block btn-twitter">Twitter</a>
 </div>
```

*Hoooooly shit*. What class is doing what? What the heck do I do if I wanted to change the appearance? What should I edit? Do I take away or add another `btn` class? Do I edit the CSS for one of the classes, and if so, which one? Seriously, look at all those classes!

I guess a counter-argument would be, "That's only because you didn't write the code. I'm sure that the original code author knows completely what is going on." That's (probably) true at the time the author wrote that code. But I guarantee you 1 week later he will be just as confused as I am now. And what if he's not working alone? What if he has teammates who also need to understand his code? 


This is a pretty extreme example, with Bootstrap already being pretty outdated in the industry. However, I still see modern style guides recommend "adding an utility class in HTML". No, that is the wrong approach. HTML is purely for architecture, and CSS is purely for design. If you want to edit the appearance of something, you should know exactly where you need to edit it. An utility class completely breaks this. This brings me to the first rule......

## Rule #1: A Single Class Per Element

This is the most important rule; the foundation which *LucidCSS* is built upon. Let me say repeat it for emphasis, there should only be a *single class* per element. Why? It makes things simple, easy to understand, and very maintainble. 

This rule does change a few things though. For starters, **CSS classes are no longer modular.** CSS (anti)patterns like `class="btn btn-social btn-block btn-google` no longer work due to this rule. Hold on, don't panic yet. Modularity still exists......

## Rule #2: Modularity Through Mixins

Instead of the HTML `class=` attribute being a container for modular CSS classes, your singular CSS class is the container for modular mixins. Mixins are good &mdash; crazy good. Remember the messy Bootstrap example above? Let me share the LucidCSS version of it:

```html
<div class="home__social-buttons">
    <a href="#" class="button--google">Google</a>
    <a href="#" class="button--twitter">Twitter</a>
 </div>
```
```scss
.home__social-buttons {
    @include container($default-padding);
    @include grid(1, 3);
}

.button--google {
    @include social-button($color--google);
}

.button--twitter {
    @include social-button($color--twitter);
}
```

Look how much cleaner this is to both read and write! What if you need to edit the appearance of the button to increase the padding? In *LucidCSS*, it is this simple:

```
.button--twitter {
    @include social-button($color--twitter);
    padding: 4em 8em;
}
```

The newly defined padding value comes after and overrides the previous padding value of `social-button`. Let's go back to the Bootstrap HTML code and give the same scenario:

```
<div class="col-xs-3 col-md-1 col-lg-1 social-btn-container">
    <a href="#" class="btn btn-social btn-block btn-google">Google</a>
    <a href="#" class="btn btn-social btn-block btn-twitter">Twitter</a>
 </div>
 ```
 
 If we wanted to only increase the padding of the Twitter button for only this instance, there are only three ways of doing it, and all are pretty bad. 
 
 * The first way is using inline CSS `style="padding: 4em 8em"`. This is pretty bad as it adds one more place where style is designated, which makes things even more harder to maintain. 
 * The second way is to add one more class `btn-extra-padding` to the already long list of classes. This is pretty bad because it makes things even more confusing, and that you are essentially creating a new class just to add padding. You also have to ensure that the specificity of `btn-extra-padding` is greater than the `btn` class that provides padding, which can be troublesome.
 * The third way is creating a variant class called `btn--big`. This method is bad too because it's not modular. What if you wanted the font size to be slightly bigger and have bigger padding? Do you create `btn--big-padding-and-font-size`?

*LucidCSS* avoids all of these problems by having one CSS class per element.

Mixin has another advantage over classes: they can accept arguments. When you create a new mixin, abstract the CSS rules that you believe will change often. Use default values too so you don't need to rewrite it every time when calling the mixin.

```scss
@mixin social-button($color: color(theme),
                    $margin-bottom: $default-margin} {
    padding: 2rem 4rem;
    background-color: $color;
    border-color: mix($color, black, 10%);
    margin-bottom: $margin-bottom;
    display: inline-block;
}
```

Be careful not to create too many parameters for a mixin though. Remember, the goal is simplicity, and having a parameter for every single CSS rule is confusing. Sometimes, it is better to create a *mixin variant* instead of adding more parameters.

```scss
@mixin social-button--small($color: color(theme),
                            $margin-bottom: $default-margin) {
    padding: 1rem 2rem; // half of regular social-button
    background-color: $color;
    border-color: mix($color, black, 10%);
    margin-bottom: $margin-bottom;
    display: inline-block;                       
}
```

There is no file size penalty for having lots and lots of mixin variants because the mixins themselves are not compiled in CSS, only the inclusions are.

## Rule #3: Namespace

>In many programming languages, namespacing is a technique employed to avoid collisions with other objects or variables in the global namespace. They're also extremely useful for helping organize blocks of functionality in your application into easily manageable groups that can be uniquely identified.
><cite><a href="https://addyosmani.com/blog/essential-js-namespacing/">Addy Osmani</a></cite>

I'm going to divide HTML elements into "outer" and "inner" elements. Outer elements are `div` or `section` that are direct children of the `body`. Inner elements are the elements contained by outer elements.

Outer elements are namespaced with the format of `page-name__container-name`. Sometimes, there are global modules that are not page-specific. In that case, name them like `global__container-name`. The `container-name` portion should concisely describe the content inside of the container. **Every outer container class should be completely, completely unique, and not to be re-used.** Inner element classes can be re-used, but you still need to follow the rule of having a singular class per element.

Here is some code example.

```
<nav class="global__nav">
 <!-- code for navigation bar -->
</nav>



<section class="about__introduction">
    <h1 class="title">Who I Am</h1>
    <p class="body">Award winning web developer from Bellevue, Washington</p>
</section>

<section class="about__featured-on">
    <h1 class="title">Featured On:</h1>
    <div class="thumbnail-section>
        <img class="thumbnail" src="google.png">
        <img class="thumbnail" src="twitter.png">
    </div>
</section class="about__featured-on">



<footer class="global__footer">
 <!-- code for footer -->
</nav>
```

And here is some sample Sass code for it:

```scss
.about__introduction {
  @include container;
  
    .title {
      @include size(h2);
      text-align: center;
    }
  
    .body {
      @include size(p);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
}


.about__featured-on {
  @include container($color--grey);
  
    .title {
      @include size(h3);
      color: $color--theme;
      letter-spacing: 0.04rem;
    }
  
    .thumbnail-section {
      width: 100%;
      padding: $default-padding;
    }
  
        .thumbnail {
          border: 1px solid $color--grey;
          width: 6em;
          height: 6em;
          display: inline-block;
          margin-right: 2em;
        }
}
```

One thing that you will immediately notice is that nesting is used. You've probably heard so many times how you should never nest in Sass and that it can create a specificity nightmare. In *LucidCSS*, nesting is cleverly used to *avoid* specificity issues. In fact, you don't need to worry about specificity at all because every single line of code you write in a namespace is quarantined to that namespace. It will not affect *anything* outside of the namespace! Brilliant!

This also lets you simplify class names for inner elements. `about__introduction` and `about__featured-on` both contain a class called `title`, but the two are styled completely different and are not related at all. They are simply called `title` because "title" is the simplest name I thought of, and it clearly describes the content in relationship to the section. *When you work in a section, you seriously do not need to worry about overlapping with other sections at all!*


Here are some CSS coding suggestions for LucidCSS:

1. The order of your CSS classes should reflect the layout appearance of the HTML webpage. Things at the top of the HTML webpage should be listed first in CSS. Top to bottom, while left to right if there are multiple grid elements in a row.
2. Use line breaks aggressively to organize.
2. Your CSS classes should reflect the parent-child relationships of the HTML DOM with multiple indents. Notice how `thumbnail-section` is clearly the parent of `thumbnail` just by looking at in the stylesheet.
3. Only nest a single layer generally. Notice how `thumbnail-section` is not nested within `thumbnail` in my example.
4. To override a declaration in a mixin, the declaration has to be below the mixin. Mixins should generally be placed at the top of the every class.


## Summary

* **Rule #1: A Single Class Per Element.** The complete separation of concerns between HTML and CSS is important for maintainability
* **Rule #2: Modularity Through Mixins.** Mixins are extremely powerful and allows for much more flexibility as a modular component than a CSS class.
* **Rule #3: Namespace.** Namespacing completely solves the specificity problem and gives you freedom with naming classes.

These three rules make up *LucidCSS*. One good thing about *LucidCSS* is that it is not a framework; it is just a style guide. That means that you can easily adapt your favorite framework to make it *lucid*. This article was written in a pretty casual tone. To get an in-depth and formal overview of LucidCSS, [check out its website](http://lucidcss.io).